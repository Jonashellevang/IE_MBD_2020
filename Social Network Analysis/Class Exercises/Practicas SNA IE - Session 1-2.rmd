---
title: "Networks in Igraph"
output: html_notebook
editor_options: 
  chunk_output_type: inline
---

# 1. Networks in igraph

**igraph** is a collection of network analysis tools with the emphasis on efficiency, portability and ease of use. igraph is open source and free. igraph can be programmed in R, Python, Mathematica and C/C++. Lessons will cover the igraph R package but feel free to investigate on your own the python package. 

# 1.1 Create networks

First let's remove all the objects we created so far and install and load the package in order to start from an empty environment.

```{r, echo=FALSE, error=FALSE, message=FALSE, warning=FALSE, fig.showtext=FALSE}
rm(list=ls())
#install.packages("igraph")
library('igraph')
```


We can generate graphs using the graph function of igraph. It receives the following arguments:

* Edges (A vector defining the edges)
* n (The number of vertices in the graph)
* isolates (names of isolate vertices)
* directed (Whether to create a directed graph)
* simplify (whether to simplify the graph)

You can check ?graph for more information.

Let's start with the simplest one: an undirected graph with three edges.
```{r}
g1 <- graph( edges=c(1,2, 2,3, 3, 1), n=3, directed=F ) 

plot(g1)
```

You can obtain more information about the graph executing class and executing g1 itself. 

The description of an igraph object starts with up to four letters:

1. D or U, for a directed or undirected graph
2. N for a named graph (where nodes have a name attribute)
3. W for a weighted graph (where edges have a weight attribute)
4. B for a bipartite (two-mode) graph (where nodes have a type attribute)

The two numbers that follow (7 5) refer to the number of nodes and edges in the graph. The description also lists node & edge attributes, for example:

* (g/c) - graph-level character attribute
* (v/c) - vertex-level character attribute
* (e/n) - edge-level numeric attribut

```{r}
class(g1)

g1
```

Now, do you think you can create a graph with 10 nodes?

```{r}
g2 <- graph( edges=c(1,2, 2,3, 3, 1), n=10)

plot(g2)
```


What about doing it directed?
```{r}

```




When the edge list has vertex names, the number of nodes is not needed and it is considered directed.
```{r}
g4 <- graph( c("A", "B", "B", "C", "C", "A")) 


plot(g4)
```

In named graphs we can specify isolates by providing a list of their names.
```{r}
g5 <- graph( c("A", "B", "B", "C", "C", "A"), 
             isolates=c("D", "E", "F", "G") )  

plot(g5)


```




# 1.2 Edge, vertex, and network attributes

Access vertices and edges with function V(graph) and E(graph):


```{r}
?V
E(g5)
V(g5)
```

You can access the network adjacency matrix directly:

```{r}
g5[]
```


Attributes can be added to the network, vertices, or edges. 
With vertex_attr to query the atributes of a given graph.
Usage: vertex_attr(graph, name, index = V(graph)), where

* name: Name of the attribute to query. If missing, then all vertex attributes are returned in a list.
* index: A vertex sequence, to query the attribute only for these vertices.

In the following case we only have the vertex name (that is automatically generated when we created the network).

```{r}
vertex_attr(g5)
```

To set the attributes the following syntax can be used.

```{r}
V(g5)$type <- c("Vowel", "Consonant", "Consonant", "Consonant", "Vowel", "Consonant", "Consonant")


E(g5)$type <- "whatever" # Edge attribute, assign "whatever" to all edges
vertex_attr(g5)
edge_attr(g5)
```

Create your own attribute for vowels. This attribute must be boolean (True if it is a vowel).
```{r}


```


The color is also an attribute.

```{r}
plot(g5, edge.arrow.size=.5, vertex.label.color="black", vertex.label.dist=1.5, vertex.color=c( "pink", "skyblue")[1+(V(g5)$type=="Vowel")] ) 

```

Simple graphs are graphs which do not contain loop and multiple edges. The simplify(graph) function does this for us. Create a graph g6 which contains loops and multiple edges and plot it. Then simplify it and plot it again.

```{r}
?simplify
```

#1.3 Specific graphs and graph models

There are some specific graphs that can be done with igraph functions:

* Empty graph
* Full graph
* Simple star graph
* Tree graph
* Ring graph
* ...


You have an example here. Check what others you can find in the documentation: atlas, graph.atlas, graph_from_atlas; chordal_ring, graph.extended.chordal.ring, make_chordal_ring; directed_graph, graph, graph.famous, make_directed_graph, make_graph, make_undirected_graph, undirected_graph; empty_graph, graph.empty, make_empty_graph; from_edgelist, graph.edgelist, graph_from_edgelist; from_literal, graph.formula, graph_from_literal; full_citation_graph, graph.full.citation, make_full_citation_graph; graph.lattice, lattice, make_lattice; graph.ring, make_ring, ring; graph.star, make_star, star; graph.tree, make_tree, tree


https://igraph.org/r/doc/igraph.pdf


```{r}
fg <- make_full_graph(40)

plot(fg, vertex.size=10, vertex.label=NA)
```

To write a graph to a file we can use write_graph(graph, file, format). Formats available: "edgelist", "pajek", "ncol", "lgl", "graphml", "dimacs", "gml", "dot"

Change the path to the one you want to use.
```{r}
g <- sample_smallworld(dim=2, size=10, nei=1, p=0.1)
write_graph(g, "graph_edgelist.txt", "edgelist")
write_graph(g, "graph_ncol.txt", "ncol")
write_graph(g, "graph_lgl.txt", "lgl")
write_graph(g, "graph_pajek.txt", "pajek")
write_graph(g, "graph_graphml.txt", "graphml")
write_graph(g, "graph_gml.txt", "gml")
```


To read from a file, the function read_graph(file) can be used. It supports several formats: "edgelist", "pajek", "ncol", "lgl", "graphml", "dimacs", "graphdb", "gml"

```{r}
g2 <- read_graph("graph_edgelist.txt", "edgelist")
g2 <- read_graph("graph_ncol.txt", "ncol")
g2 <- read_graph("graph_lgl.txt", "lgl")
g2 <- read_graph("graph_pajek.txt", "pajek")
g2 <- read_graph("graph_graphml.txt", "graphml")
g2 <- read_graph("graph_gml.txt", "gml")
```

Graphs can also be created from datasets or adjacency matrices

```{r}
links <- data.frame(from=c('A','B','C', 'A', 'A'), to=c('B','C','A', 'D', 'E'), weight=c(2,2, 20, 3, 10))
nodes <- data.frame(id=c('A','B','C', 'D', 'E', 'F'), type=c(1,2,2,2,1,2), type_name=c('Vowel', 'Consonant', 'Consonant', 'Consonant', 'Vowel', 'Consonant'))

g <- graph_from_data_frame(d=links, vertices=nodes, directed=T) 

adjmatrix <- matrix( 
    c(0, 1, 1, 1, 0, 0, 0, 0, 
      0, 0, 1, 0, 1, 1, 0, 0,
      0, 0, 0, 0, 0, 0, 1, 0,
      1, 0, 0, 0, 0, 0, 0, 0,
      0, 1, 1, 0, 0, 1, 0, 0,
      1, 0, 1, 0, 0, 0, 0, 1,
      0, 1, 1, 1, 0, 1, 0, 1,
      0, 0, 0, 1, 1, 1, 1, 0), 
    nrow=8,              
    ncol=8,
    byrow=TRUE)  

# Create a directed graph
g2 <- graph_from_adjacency_matrix(adjmatrix)
```

## Plotting with igraph

Plotting with igraph: the network plots have a wide set of parameters you can set. Those include node options (starting with  vertex) and edge options (starting with edge). 

A list of selected options is included below, but you can also check out  ?igraph.plotting for more information.

### NODES	 
* **vertex.color**	 Node color
* **vertex.frame.color**	 Node border color
* **vertex.shape**	 "none", "circle", "square", "csquare", "rectangle" "crectangle", "vrectangle", "pie", "raster",  "sphere"
* **vertex.size**	 Size of the node (default is 15)
* **vertex.size2**	 The second size of the node (e.g. for a rectangle)
* **vertex.label**	 Character vector used to label the nodes
* **vertex.label.family**	 Font family of the label (e.g."Times", "Helvetica")
* **vertex.label.font**	 Font: 1 plain, 2 bold, 3, italic, 4 bold italic, 5 symbol
* **vertex.label.cex**	 Font size (multiplication factor, device-dependent)
* **vertex.label.dist**	 Distance between the label and the vertex
* **vertex.label.degree**	 The position of the label in relation to the vertex

### EDGES	 
* **edge.color**	 Edge color
* **edge.width**	 Edge width, defaults to 1
* **edge.arrow.size**	 Arrow size, defaults to 1
* **edge.arrow.width**	 Arrow width, defaults to 1
* **edge.lty**	 Line type, could be "blank", "solid", "dashed", "dotted", "dotdash", "longdash", "twodash"
* **edge.label**	 Character vector used to label edges
* **edge.label.family**	 Font family of the label (e.g."Times", "Helvetica")
* **edge.label.font**	 Font: 1 plain, 2 bold, 3, italic, 4 bold italic, 5 symbol
* **edge.label.cex**	 Font size for edge labels
* **edge.curved**	 Edge curvature, range 0-1 (FALSE sets it to 0, TRUE to 0.5)
* **arrow.mode**	 Vector specifying whether edges should have arrows, possible values: 0 no arrow, 1 back, 2 forward, 3 both


### OTHER	 
* **margin**	 Empty space margins around the plot, vector with length 4
* **frame**	 if TRUE, the plot will be framed
* **main**	 If set, adds a title to the plot
* **sub**	 If set, adds a subtitle to the plot


```{r}
plot(g, edge.arrow.size=.4, edge.curved=.1)

colrs <- c("tomato", "gold")

V(g)$color <- colrs[V(g)$type]
plot(g) 
legend(x=-1.5, y=-1.1, c("Vowel","Consonant"), pch=21, col="#777777", pt.bg=colrs, pt.cex=2, cex=.8, bty="n", ncol=1)
```


R and igraph allow for interactive plotting of networks this can be done using tkplot.

```{r}
tkid <- tkplot(g) #tkid is the id of the tkplot that will open

l <- tkplot.getcoords(tkid) # grab the coordinates from tkplot

tk_close(tkid, window.close = T)

plot(g, layout=l)
```


# 2. Network and node descriptives

The function degree() has a mode of in for in-degree, out for out-degree, and all or total for total degree.
```{r}
?degree

is.directed(g)

deg <- degree(g, mode="all")

plot(g, vertex.size=deg*7)


```

Check how the graph changes with different modes.

```{r}
V(g)$color <- colrs[V(g)$type]
plot(g) 

```



Degree distribution can be seen through an histogram of the frequency of the node degrees.

```{r}
hist(deg, main="Histogram of node degree")
```

Or we can see it with the cumulative frequency.

```{r}
?degree_distribution
deg.dist <- degree_distribution(g, cumulative=T, mode="all")

plot( x=0:max(deg), y=1-deg.dist, pch=19, cex=1.2, col="orange", 

      xlab="Degree", ylab="Cumulative Frequency")
```

## Centrality

There are several packages that implement centrality indices.
The big network and graph packages such as igraph,sna, qgraph, and tidygraph, which are designed as general purpose packages for network analysis. Hence, they also implement some centrality indices.

* **igraph**: degree (degree()), weighted degree (graph.strength()), betweenness (betweenness()), closeness (closeness()), eigenvector (eigen_centrality()), alpha centrality (alpha_centrality()), power centrality (power_centrality()), PageRank (page_rank()), eccentricity (eccentricity()), hubs and authorities (authority_score() and hub_score()) and subgraph centrality (subgraph_centrality()).
* **sna**: flow betweenness (flowbet()), load centrality (loadcent()), Gil-Schmidt Power Index (gilschmidt()), information centrality (infocent()) and stress centrality (stresscent())
* **qgraph**: it has a generic function centrality_auto() which returns: degree, strength (weighted degree), betweenness and closeness.


There are also some dedicated centrality packages, such as centiserve, **CINNA**, **influenceR** and **keyplayer**.

```{r}
g <- igraph::sample_smallworld(1, 30, 2, 0.05)

dg = degree(g, mode="in")

bt = betweenness(g)

cl = closeness(g)

ec = eigen_centrality(g)

pr = page_rank(g)

```

Now, plot the graph changing the size or the color of the net with the value of centrality.

```{r}



```




```{r}
##Be sure you have the last version of R, you can use installer
#install.packages('sna')
#install.packages('centiserve')
#install.packages('CINNA')
#install.packages('expm')
#install.packages('igraphdata')

library('sna')
library('centiserve')
library('CINNA')
library('expm')
library('igraphdata')

all_indices <- function(g){ 
  res <- matrix(0,vcount(g),34)
  res[,1] <- igraph::degree(g)
  res[,2] <- igraph::betweenness(g) 
  res[,3] <- igraph::closeness(g)
  res[,4] <- igraph::eigen_centrality(g)$vector
  res[,5] <- 1/igraph::eccentricity(g)
  res[,6] <- igraph::subgraph_centrality(g)
  
  A <- get.adjacency(g,sparse=F)
  res[,7] <- sna::flowbet(A)
  res[,8] <- sna::loadcent(A)
  res[,9] <- sna::gilschmidt(A)
  res[,10] <- sna::infocent(A)
  res[,11] <- sna::stresscent(A)
  
  res[,12] <- 1/centiserve::averagedis(g)
  res[,13] <- centiserve::barycenter(g)
  res[,14] <- centiserve::closeness.currentflow(g)
  res[,15] <- centiserve::closeness.latora(g)
  res[,16] <- centiserve::closeness.residual(g)
  res[,17] <- centiserve::communibet(g)
  res[,18] <- centiserve::crossclique(g)
  res[,19] <- centiserve::decay(g)
  res[,20] <- centiserve::diffusion.degree(g)     
  res[,21] <- 1/centiserve::entropy(g)
  res[,22] <- centiserve::geokpath(g)
  res[,23] <- centiserve::laplacian(g)             
  res[,24] <- centiserve::leverage(g)          
  res[,25] <- centiserve::lincent(g)   
  res[,26] <- centiserve::lobby(g)
  res[,27] <- centiserve::markovcent(g)        
  res[,28] <- centiserve::mnc(g)   
  res[,29] <- centiserve::radiality(g)         
  res[,30] <- centiserve::semilocal(g)   
  res[,31] <- 1/centiserve::topocoefficient(g) 

  res[,32] <- CINNA::dangalchev_closeness_centrality(g)
  res[,33] <- CINNA::harmonic_centrality(g)
  res[,34] <- 1/CINNA::local_bridging_centrality(g)
  apply(res,2,function(x) round(x,8))
}

res1 <- all_indices(g)


```

Calculate all these metrics with CINNA library and its functions calculate_centralities() and proper_centralities (to get 10 proper measures). Having done this calculate the correlation and plot it using corrplot.

```{r}


```

The problem is now that we have a lot of measures that are correlated. In orther to distinguish the most informative measures we could use PCA using pca_centralities.

```{r}
calculate_centralities(g, include = proper_centralities(g)[1:10])%>%
  pca_centralities(scale.unit = TRUE)

```



```{r}
data(karate)
A <- get.adjacency(karate, sparse=FALSE)
sna::gplot.target(A, degree(A), main="Degree", circ.lab = FALSE, circ.col="skyblue", usearrows = FALSE, vertex.col=c("blue", rep("red", 32), "yellow"), edge.col="darkgray")
```
Change the previous plot to show various vertex centralities for the karate club network. 

```{r}

```
